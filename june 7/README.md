# Production Assignment

<details>
  <summary>(1/2) Digital Art with Transformations</summary>

## Digital Art with Transformations
Having already worked with trigonometric functions and [the rotate() function](https://github.com/mike-leo-k/intro-to-im/blob/master/june%203), I decided to apply the concepts I observed in class, including the translate() function and scaling the the trigonometric function.

I first translated a sine graph (without scaling, generated by plotting points), with the following result:
<p align="center">
  <img width="700" src="https://github.com/mike-leo-k/intro-to-im/blob/master/june%207/trans_1.png">
</p>

Then, scaling the graph by a fact of 10:
<p align="center">
  <img width="700" src="https://github.com/mike-leo-k/intro-to-im/blob/master/june%207/trans_2.png">
</p>

Then, using a for() loop, with pushMatrix() at the beginning followed by an incremental downward translation (using translat(0, i), i += 15) and a subsequent popMatric(), I repeated the sine graph throughout the screen:
<p align="center">
  <br>
  <img width="500" src="https://github.com/mike-leo-k/intro-to-im/blob/master/june%207/trans_3.png">
</p>

Now, when rotating the coordinate system (with the rotate() transformation), translation is also required for the drawings to be displayed on screen. Implementing the function in the last step, I added a second for loop that would draw the same graphs vertically as well:
<p align="center">
  <img width="500" src="https://github.com/mike-leo-k/intro-to-im/blob/master/june%207/trans_4.png">
</p>

Using strokeWeight(), I increased the size of the points (and thus the graphs):
<p align="center">
  <br>
  <img width="500" src="https://github.com/mike-leo-k/intro-to-im/blob/master/june%207/trans_5.png">
</p>

Finally, using random(255) in the stroke(R, G, B) function, I set each point on each graph to have a random color:
<p align="center">
  <br>
  <img width="500" src="https://github.com/mike-leo-k/intro-to-im/blob/master/june%207/trans_6.png">
</p>


### Final Render
<p align="center">
  <img width="500" src="https://github.com/mike-leo-k/intro-to-im/blob/master/june%207/final_render.gif">
</p>

## Challenges/Discoveries
* Figuring out how to properly scale up the sine graph. Realizing that the x coroodinate needed to be proportionally scaled as well seems obvious in retrospect.
* I first tried using the fill() function to change the color of the points, but googling told me that stroke() controlled the colors of points.
* Calculating how much translation was required post-rotation. Thinking of the coordinate system as a movable graph sheet really helped.

</details>

<details>
  <summary>(2/2) Data Visualization</summary>
  
## Data Visualization
Inspired by [Pong](https://en.wikipedia.org/wiki/Pong), one of the earliest video games created, Pong Practice is a simple one person video game intended to allow the player to "practice" Pong. Instead of two paddles, there is only paddle to the right of the screen, and the objective is to prevent a bouncing ball from touching the right edge. Pong Practice emulates practicing tennis/table tennis/lacrosse shots against a wall.

The code that runs the game uses object-oriented programming to define the paddle and the ball as objects, as well as defining the various functions that can be applied to them.

## Screen Captures of Game:

### Pong Practice in action
![GIF of the game being played](https://github.com/mike-leo-k/intro-to-im/blob/master/june%203/pong_practice.gif)

## Challenges/Discoveries
* Figuring out how to navigate between three separate screens (I envisioned the game to have a start screen and a game over screen in addition to actual gameplay) was challenging. I settled on checking a variable for one three values in an if-else chain in void main(), but unfortunately didn't have enough time to implement it.
* Because I wanted to use the up and down arrow keys, the keyPressed() function wouldn't work. I learned you could use keyCode instead.
* Used text that constantly updates to reflect the score.
* Got a little lost in all the coordinate arithmetic I had to do to accurately check the position of the ball with relation to the paddle.

</details>
